<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Rain - The Real Deal</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden; 
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d', { alpha: false });

        let W, H, cols, rows;
        let cfg = {
            fontSize: 16,
            speed: 0.35,
            color: '#00ff41'
        };

        window.addEventListener('message', e => {
            if (e.origin !== location.origin) return;
            if (e.data && e.data.cfg) {
                Object.assign(cfg, e.data.cfg);
                init();
            }
        });

        // ── Authentic character set ──
        // Half-width katakana (displayed mirrored in the film) + digits + symbols
        const CHARS = 'ﾊﾋｼﾂｳｰﾅﾐﾓﾆｻﾜｵﾘﾎﾏｴｷﾑﾃｹﾒｶﾕﾗｾﾈｽﾀﾇ0123456789Z:.*+"=<>|¦_'.split('');
        const rc = () => CHARS[(Math.random() * CHARS.length) | 0];

        // ── Color helpers ──
        function hexToRGB(hex) {
            return {
                r: parseInt(hex.slice(1, 3), 16),
                g: parseInt(hex.slice(3, 5), 16),
                b: parseInt(hex.slice(5, 7), 16)
            };
        }

        // ── Grid model ──
        // Glyphs are STATIONARY in the grid. "Rain" is a wave of illumination.
        let grid = [];        // grid[row][col] = { char, brightness, highlighted, flickering, flickerTimer }
        let streams = [];     // Active rain/delete streams
        let colCooldown = []; // Per-column spawn cooldowns
        let colActive = [];   // Per-column active stream count (updated each frame)

        class Stream {
            constructor(col, startRow) {
                this.col = col;
                this.row = startRow !== undefined ? startRow : -Math.floor(Math.random() * rows * 0.5);
                this.speed = 0.3 + Math.random() * 0.7;
                this.length = 8 + Math.floor(Math.random() * 22);
                this.highlighted = Math.random() < 0.2;  // ~1 in 5 have bright white head
                this.accum = 0;
                this.alive = true;
                this.spawned = 0;
                this.maxSpawn = this.length + 4 + ((Math.random() * 10) | 0);
            }

            step() {
                this.row++;
                this.spawned++;

                if (this.row >= 0 && this.row < rows) {
                    const cell = grid[this.row][this.col];
                    cell.char = rc();
                    cell.brightness = 1.0;
                    cell.isHead = true;
                    cell.highlighted = this.highlighted;
                    if (Math.random() < 0.15) {
                        cell.flickering = true;
                        cell.flickerTimer = 2 + ((Math.random() * 5) | 0);
                    }
                }

                if (this.spawned > this.maxSpawn || this.row > rows + 5) {
                    this.alive = false;
                }
            }

            update(dt) {
                this.accum += this.speed * dt;
                while (this.accum >= 1) {
                    this.accum -= 1;
                    this.step();
                    if (!this.alive) break;
                }
            }
        }

        class DeleteStream {
            constructor(col) {
                this.col = col;
                this.row = -((Math.random() * 6) | 0);
                this.speed = 0.5 + Math.random() * 0.6;
                this.accum = 0;
                this.alive = true;
            }

            update(dt) {
                this.accum += this.speed * dt;
                while (this.accum >= 1) {
                    this.accum -= 1;
                    this.row++;
                    if (this.row >= 0 && this.row < rows) {
                        const cell = grid[this.row][this.col];
                        cell.brightness = 0;
                        cell.char = '';
                        cell.isHead = false;
                        cell.flickering = false;
                    }
                    if (this.row > rows) { this.alive = false; break; }
                }
            }
        }

        function init() {
            const fs = cfg.fontSize || 16;
            W = c.width = innerWidth;
            H = c.height = innerHeight;
            cols = Math.floor(W / fs);
            rows = Math.floor(H / fs) + 2;

            grid = [];
            for (let r = 0; r < rows; r++) {
                grid[r] = [];
                for (let cl = 0; cl < cols; cl++) {
                    grid[r][cl] = {
                        char: '',
                        brightness: 0,
                        isHead: false,
                        highlighted: false,
                        flickering: false,
                        flickerTimer: 0
                    };
                }
            }

            streams = [];
            colCooldown = new Array(cols).fill(0);
            colActive = new Array(cols).fill(0);

            // Seed streams across all columns
            for (let cl = 0; cl < cols; cl++) {
                const count = 1 + ((Math.random() * 2) | 0);
                for (let i = 0; i < count; i++) {
                    streams.push(new Stream(cl, -((Math.random() * rows * 1.2) | 0)));
                }
            }

            // ── Warm-up: pre-simulate ~3 seconds so the screen starts full ──
            const warmupSteps = 180; // ~3 sec at 60fps
            const warmupDt = 1 / 60;
            const spdMul = (cfg.speed / 0.35) * (fs * 0.7);
            for (let i = 0; i < warmupSteps; i++) {
                for (const s of streams) {
                    const sv = s.speed;
                    s.speed = sv * spdMul;
                    s.update(warmupDt);
                    s.speed = sv;
                }
                streams = streams.filter(s => s.alive);
                // Simplified fade for warmup (frame-rate independent)
                for (let r = 0; r < rows; r++) {
                    for (let cl = 0; cl < cols; cl++) {
                        const cell = grid[r][cl];
                        if (cell.brightness > 0 && !cell.isHead) {
                            cell.brightness *= 0.96;
                            if (cell.brightness < 0.01) {
                                cell.brightness = 0;
                                cell.char = '';
                            }
                        }
                        cell.isHead = false;
                    }
                }
                // Simplified spawning during warmup
                if (i % 3 === 0) {
                    for (let cl = 0; cl < cols; cl++) {
                        let active = 0;
                        for (const s of streams) if (s.alive && s.col === cl) active++;
                        if (active < 1 && Math.random() < 0.15) {
                            streams.push(new Stream(cl));
                        }
                    }
                }
            }

            lastTime = performance.now();
        }

        window.addEventListener('resize', init);
        init();

        // ── Spawn management ──
        function spawnStreams() {
            // Build per-column active counts in one pass
            colActive.fill(0);
            for (const s of streams) {
                if (s.alive) colActive[s.col]++;
            }

            for (let cl = 0; cl < cols; cl++) {
                if (colCooldown[cl] > 0) {
                    colCooldown[cl]--;
                    continue;
                }

                const active = colActive[cl];

                if (active < 1 && Math.random() < 0.08) {
                    streams.push(new Stream(cl));
                    colCooldown[cl] = 8 + ((Math.random() * 15) | 0);
                } else if (active < 2 && Math.random() < 0.02) {
                    streams.push(new Stream(cl));
                    colCooldown[cl] = 12 + ((Math.random() * 20) | 0);
                }

                // Occasional deletion streams to create breathing room
                if (active > 0 && Math.random() < 0.003) {
                    streams.push(new DeleteStream(cl));
                }
            }
        }

        // ── Render loop ──
        let lastTime = performance.now();

        function frame(now) {
            const rawDt = (now - lastTime) / 1000;
            const dt = Math.min(rawDt, 0.05);
            lastTime = now;

            const fs = cfg.fontSize || 16;
            const baseSpeed = cfg.speed || 0.35;
            const speedMul = (baseSpeed / 0.35) * (fs * 0.7);

            // Update streams
            for (const s of streams) {
                const sv = s.speed;
                s.speed = sv * speedMul;
                s.update(dt);
                s.speed = sv;
            }

            // Prune dead streams
            streams = streams.filter(s => s.alive);

            // Spawn replacements
            spawnStreams();

            // ── Fade & flicker (frame-rate independent) ──
            // Compute per-frame fade multiplier from dt
            // Target: brightness halves in ~0.8 seconds
            const halfLife = 0.6 + baseSpeed * 0.5;
            const fadeMul = Math.pow(0.5, dt / halfLife);

            for (let r = 0; r < rows; r++) {
                for (let cl = 0; cl < cols; cl++) {
                    const cell = grid[r][cl];

                    if (cell.brightness > 0 && !cell.isHead) {
                        cell.brightness *= fadeMul;
                        if (cell.brightness < 0.008) {
                            cell.brightness = 0;
                            cell.char = '';
                            cell.flickering = false;
                        }
                    }
                    cell.isHead = false;

                    // Glyph flicker (periodic character swap)
                    if (cell.flickering && cell.brightness > 0.04) {
                        cell.flickerTimer--;
                        if (cell.flickerTimer <= 0) {
                            cell.char = rc();
                            cell.flickerTimer = 2 + ((Math.random() * 5) | 0);
                        }
                    }
                }
            }

            // ── Draw ──
            const { r: cr, g: cg, b: cb } = hexToRGB(cfg.color || '#00ff41');

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, W, H);

            ctx.font = `${fs}px "MS Gothic", "Yu Gothic", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Batch: draw non-glowing cells first, then glowing heads
            // This minimizes shadowBlur state changes (expensive)
            
            // Pass 1: Normal trail cells (no glow)
            ctx.shadowBlur = 0;
            for (let r = 0; r < rows; r++) {
                for (let cl = 0; cl < cols; cl++) {
                    const cell = grid[r][cl];
                    if (cell.brightness <= 0 || !cell.char) continue;
                    const b = cell.brightness;

                    // Skip heads — drawn in pass 2
                    if (cell.highlighted && b > 0.85) continue;
                    if (b > 0.9) continue;

                    const x = cl * fs + fs / 2;
                    const y = r * fs;

                    // Phosphor decay curve
                    const intensity = b * b; // Quadratic falloff for that CRT glow feel
                    const rr = (cr * intensity * 0.12) | 0;
                    const gg = (cg * intensity) | 0;
                    const bb = (cb * intensity * 0.12) | 0;
                    ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
                    ctx.fillText(cell.char, x, y);
                }
            }

            // Pass 2: Bright heads and recently-lit cells (with glow)
            for (let r = 0; r < rows; r++) {
                for (let cl = 0; cl < cols; cl++) {
                    const cell = grid[r][cl];
                    if (cell.brightness <= 0 || !cell.char) continue;
                    const b = cell.brightness;

                    const x = cl * fs + fs / 2;
                    const y = r * fs;

                    if (cell.highlighted && b > 0.85) {
                        // ★ Bright white head — the iconic leading cursor
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = `rgba(${cr},${cg},${cb},0.9)`;
                        ctx.fillStyle = `rgba(255,255,255,${Math.min(1, b * 1.1).toFixed(2)})`;
                        ctx.fillText(cell.char, x, y);
                    } else if (b > 0.9) {
                        // Recently placed: bright green/white mix with subtle glow
                        const mix = (b - 0.9) * 10; // 0→1 over 0.9→1.0
                        const rr = (cr + (255 - cr) * mix * 0.5) | 0;
                        const gg = (cg + (255 - cg) * mix * 0.5) | 0;
                        const bb = (cb + (255 - cb) * mix * 0.5) | 0;
                        ctx.shadowBlur = 10 * mix;
                        ctx.shadowColor = cfg.color || '#00ff41';
                        ctx.fillStyle = `rgb(${rr},${gg},${bb})`;
                        ctx.fillText(cell.char, x, y);
                    }
                }
            }
            ctx.shadowBlur = 0;

            requestAnimationFrame(frame);
        }

        requestAnimationFrame(frame);
    </script>
</body>
</html>
