<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Rain Screensaver â€” Digital Rain Effect | retro.bithash.cc</title>
    <meta name="description" content="Watch cascading green katakana characters rain down your screen in this Matrix-inspired screensaver. Pure HTML5 Canvas, configurable colors and speed.">
    <link rel="canonical" href="https://retro.bithash.cc/screensavers/matrix.html">
    <meta property="og:title" content="Matrix Rain Screensaver â€” In Your Browser">
    <meta property="og:description" content="Cascading green katakana Matrix digital rain effect in HTML5 Canvas.">
    <meta property="og:url" content="https://retro.bithash.cc/screensavers/matrix.html">
    <meta property="og:image" content="https://retro.bithash.cc/og-image.png">
    <meta property="og:type" content="website">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ–¥ï¸</text></svg>">
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; }
        .back-link { position: fixed; top: 8px; left: 8px; z-index: 999; font: 12px Tahoma, Arial, sans-serif; color: rgba(255,255,255,0.4); text-decoration: none; padding: 4px 8px; transition: color 0.2s; }
        .back-link:hover { color: rgba(255,255,255,0.9); }
    </style>
</head>
<body>
    <a href="/" class="back-link">â† retro.bithash.cc</a>
    <canvas id="c"></canvas>
    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d', { alpha: false });

        let W, H, cols, rows;
        let cfg = {
            fontSize: 16,
            speed: 0.35,
            color: '#00ff41',
            density: 1.0
        };

        window.addEventListener('message', e => {
            // Accept messages from same origin or parent frame
            // On file:// both origins are 'null' (string); on https they match normally
            const validOrigin = !e.origin || e.origin === 'null' || e.origin === location.origin;
            if (!validOrigin) return;
            if (e.data && e.data.cfg) {
                const prev = { fontSize: cfg.fontSize, density: cfg.density };
                Object.assign(cfg, e.data.cfg);
                // Ensure numeric types for values that come from select elements as strings
                cfg.fontSize = parseInt(cfg.fontSize) || 16;
                cfg.speed = parseFloat(cfg.speed) || 0.35;
                cfg.density = parseFloat(cfg.density) || 1.0;
                // Only reinit grid if fontSize or density changed (expensive)
                if (cfg.fontSize !== prev.fontSize || cfg.density !== prev.density) {
                    init();
                }
                // Speed and color take effect immediately (no reinit needed)
            }
        });

        // â”€â”€ Authentic character set â”€â”€
        const CHARS = 'ï¾Šï¾‹ï½¼ï¾‚ï½³ï½°ï¾…ï¾ï¾“ï¾†ï½»ï¾œï½µï¾˜ï¾ï¾ï½´ï½·ï¾‘ï¾ƒï½¹ï¾’ï½¶ï¾•ï¾—ï½¾ï¾ˆï½½ï¾€ï¾‡0123456789Z:.*+"=<>|Â¦_'.split('');
        const rc = () => CHARS[(Math.random() * CHARS.length) | 0];

        // â”€â”€ Color helpers â”€â”€
        function hexToRGB(hex) {
            return {
                r: parseInt(hex.slice(1, 3), 16),
                g: parseInt(hex.slice(3, 5), 16),
                b: parseInt(hex.slice(5, 7), 16)
            };
        }

        // â”€â”€ Grid model â”€â”€
        let grid = [];
        let streams = [];
        let colCooldown = [];
        let colActive = [];

        class Stream {
            constructor(col, startRow) {
                this.col = col;
                this.row = startRow !== undefined ? startRow : -Math.floor(Math.random() * rows * 0.5);
                this.speed = 0.3 + Math.random() * 0.7;
                this.length = 8 + Math.floor(Math.random() * 22);
                this.highlighted = Math.random() < 0.2;
                this.accum = 0;
                this.alive = true;
                this.spawned = 0;
                this.maxSpawn = this.length + 4 + ((Math.random() * 10) | 0);
            }

            step() {
                this.row++;
                this.spawned++;
                if (this.row >= 0 && this.row < rows) {
                    const cell = grid[this.row][this.col];
                    cell.char = rc();
                    cell.brightness = 1.0;
                    cell.isHead = true;
                    cell.highlighted = this.highlighted;
                    if (Math.random() < 0.15) {
                        cell.flickering = true;
                        cell.flickerTimer = 2 + ((Math.random() * 5) | 0);
                    }
                }
                if (this.spawned > this.maxSpawn || this.row > rows + 5) {
                    this.alive = false;
                }
            }

            update(dt) {
                this.accum += this.speed * dt;
                while (this.accum >= 1) {
                    this.accum -= 1;
                    this.step();
                    if (!this.alive) break;
                }
            }
        }

        class DeleteStream {
            constructor(col) {
                this.col = col;
                this.row = -((Math.random() * 6) | 0);
                this.speed = 0.5 + Math.random() * 0.6;
                this.accum = 0;
                this.alive = true;
            }

            update(dt) {
                this.accum += this.speed * dt;
                while (this.accum >= 1) {
                    this.accum -= 1;
                    this.row++;
                    if (this.row >= 0 && this.row < rows) {
                        const cell = grid[this.row][this.col];
                        cell.brightness = 0;
                        cell.char = '';
                        cell.isHead = false;
                        cell.flickering = false;
                    }
                    if (this.row > rows) { this.alive = false; break; }
                }
            }
        }

        function init() {
            const fs = cfg.fontSize || 16;
            W = c.width = innerWidth;
            H = c.height = innerHeight;
            cols = Math.floor(W / fs);
            rows = Math.floor(H / fs) + 2;

            grid = [];
            for (let r = 0; r < rows; r++) {
                grid[r] = [];
                for (let cl = 0; cl < cols; cl++) {
                    grid[r][cl] = {
                        char: '',
                        brightness: 0,
                        isHead: false,
                        highlighted: false,
                        flickering: false,
                        flickerTimer: 0
                    };
                }
            }

            streams = [];
            colCooldown = new Array(cols).fill(0);
            colActive = new Array(cols).fill(0);

            const density = cfg.density || 1.0;

            // Seed streams â€” density controls how many per column
            for (let cl = 0; cl < cols; cl++) {
                const count = Math.max(1, Math.round((1 + Math.random()) * density));
                for (let i = 0; i < count; i++) {
                    streams.push(new Stream(cl, -((Math.random() * rows * 1.2) | 0)));
                }
            }

            // â”€â”€ Warm-up: pre-simulate so the screen starts populated â”€â”€
            const warmupSteps = 180;
            const warmupDt = 1 / 60;
            const spdMul = ((cfg.speed || 0.35) / 0.35) * (fs * 0.7);
            for (let i = 0; i < warmupSteps; i++) {
                for (const s of streams) {
                    const sv = s.speed;
                    s.speed = sv * spdMul;
                    s.update(warmupDt);
                    s.speed = sv;
                }
                streams = streams.filter(s => s.alive);
                for (let r = 0; r < rows; r++) {
                    for (let cl = 0; cl < cols; cl++) {
                        const cell = grid[r][cl];
                        if (cell.brightness > 0 && !cell.isHead) {
                            cell.brightness *= 0.96;
                            if (cell.brightness < 0.01) {
                                cell.brightness = 0;
                                cell.char = '';
                            }
                        }
                        cell.isHead = false;
                    }
                }
                if (i % 3 === 0) {
                    for (let cl = 0; cl < cols; cl++) {
                        let active = 0;
                        for (const s of streams) if (s.alive && s.col === cl) active++;
                        if (active < 1 && Math.random() < 0.15 * density) {
                            streams.push(new Stream(cl));
                        }
                    }
                }
            }

            lastTime = performance.now();
        }

        var lastTime = performance.now();

        window.addEventListener('resize', init);
        init();

        // â”€â”€ Spawn management â”€â”€
        function spawnStreams() {
            colActive.fill(0);
            for (const s of streams) {
                if (s.alive) colActive[s.col]++;
            }

            const density = cfg.density || 1.0;
            // Scale spawn thresholds by density
            const maxPerCol = Math.max(1, Math.round(2 * density));
            const spawnChance1 = 0.06 * density;  // Chance to spawn when column empty
            const spawnChance2 = 0.015 * density;  // Chance to add second stream

            for (let cl = 0; cl < cols; cl++) {
                if (colCooldown[cl] > 0) {
                    colCooldown[cl]--;
                    continue;
                }

                const active = colActive[cl];

                if (active < 1 && Math.random() < spawnChance1) {
                    streams.push(new Stream(cl));
                    colCooldown[cl] = Math.max(3, 8 + ((Math.random() * 15) | 0) - density * 4);
                } else if (active < maxPerCol && Math.random() < spawnChance2) {
                    streams.push(new Stream(cl));
                    colCooldown[cl] = Math.max(5, 12 + ((Math.random() * 20) | 0) - density * 4);
                }

                // Deletion streams (less frequent at high density)
                if (active > 0 && Math.random() < 0.003 / density) {
                    streams.push(new DeleteStream(cl));
                }
            }
        }

        // â”€â”€ Render loop â”€â”€
        function frame(now) {
            const rawDt = (now - lastTime) / 1000;
            const dt = Math.min(rawDt, 0.05);
            lastTime = now;

            const fs = cfg.fontSize || 16;
            const baseSpeed = cfg.speed || 0.35;
            const speedMul = (baseSpeed / 0.35) * (fs * 0.7);

            for (const s of streams) {
                const sv = s.speed;
                s.speed = sv * speedMul;
                s.update(dt);
                s.speed = sv;
            }

            streams = streams.filter(s => s.alive);
            spawnStreams();

            // â”€â”€ Fade (frame-rate independent) â”€â”€
            const halfLife = 0.6 + baseSpeed * 0.5;
            const fadeMul = Math.pow(0.5, dt / halfLife);

            for (let r = 0; r < rows; r++) {
                for (let cl = 0; cl < cols; cl++) {
                    const cell = grid[r][cl];
                    if (cell.brightness > 0 && !cell.isHead) {
                        cell.brightness *= fadeMul;
                        if (cell.brightness < 0.008) {
                            cell.brightness = 0;
                            cell.char = '';
                            cell.flickering = false;
                        }
                    }
                    cell.isHead = false;
                    if (cell.flickering && cell.brightness > 0.04) {
                        cell.flickerTimer--;
                        if (cell.flickerTimer <= 0) {
                            cell.char = rc();
                            cell.flickerTimer = 2 + ((Math.random() * 5) | 0);
                        }
                    }
                }
            }

            // â”€â”€ Draw â”€â”€
            const { r: cr, g: cg, b: cb } = hexToRGB(cfg.color || '#00ff41');

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, W, H);

            ctx.font = `${fs}px "MS Gothic", "Yu Gothic", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Pass 1: Trail cells (no glow â€” fast)
            ctx.shadowBlur = 0;
            for (let r = 0; r < rows; r++) {
                for (let cl = 0; cl < cols; cl++) {
                    const cell = grid[r][cl];
                    if (cell.brightness <= 0 || !cell.char) continue;
                    const b = cell.brightness;
                    if (cell.highlighted && b > 0.85) continue;
                    if (b > 0.9) continue;

                    const x = cl * fs + fs / 2;
                    const y = r * fs;
                    const intensity = b * b;
                    ctx.fillStyle = `rgb(${(cr * intensity * 0.12) | 0},${(cg * intensity) | 0},${(cb * intensity * 0.12) | 0})`;
                    ctx.fillText(cell.char, x, y);
                }
            }

            // Pass 2: Bright heads (with glow â€” fewer calls)
            for (let r = 0; r < rows; r++) {
                for (let cl = 0; cl < cols; cl++) {
                    const cell = grid[r][cl];
                    if (cell.brightness <= 0 || !cell.char) continue;
                    const b = cell.brightness;
                    const x = cl * fs + fs / 2;
                    const y = r * fs;

                    if (cell.highlighted && b > 0.85) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = `rgba(${cr},${cg},${cb},0.9)`;
                        ctx.fillStyle = `rgba(255,255,255,${Math.min(1, b * 1.1).toFixed(2)})`;
                        ctx.fillText(cell.char, x, y);
                    } else if (b > 0.9) {
                        const mix = (b - 0.9) * 10;
                        ctx.shadowBlur = 10 * mix;
                        ctx.shadowColor = cfg.color || '#00ff41';
                        ctx.fillStyle = `rgb(${(cr + (255 - cr) * mix * 0.5) | 0},${(cg + (255 - cg) * mix * 0.5) | 0},${(cb + (255 - cb) * mix * 0.5) | 0})`;
                        ctx.fillText(cell.char, x, y);
                    }
                }
            }
            ctx.shadowBlur = 0;

            requestAnimationFrame(frame);
        }

        requestAnimationFrame(frame);
    </script>
</body>
</html>
